## 예외는 진짜 예외 상황에만 사용하라  

다짜고짜 예외를 잘못 사용한 예를 살펴보자.

``` java
try{
	int i = 0;
	while(true){
		range[i++].climb();
	}
}
catch(ArrayIndexOutOfBoundsException e){
	// ...
}
``` 

위 코드의 의도는 결국 배열을 처음부터 끝까지 순회하는 것이다. 
Out of Index가 되었을 때 예외를 통해 로직을 종료한다. 
사실 이 코드는 일반적인 순회에서 나타나는 반복적인 Boundary 검사를 제거하여 어떻게든 성능을 높여보고자 하는 의도를 가지고 있는데 
다음과 같은 이유로 잘못된 추론임을 설명한다.

1. 예외는 예외 상황에만 특수하게 사용할 용도로 설계되었으므로 JVM 입장에서는 높은 퍼포먼스를 보장할 이유가 없다.
2. try-catch 블록 안에 코드는 JVM이 적용할 수 있는 최적화가 제한된다.
3. 일반적인 반복문 안에 걱정하는 바운더리 검사에 의한 지연은 발생하지 않고 JVM이 알아서 최적화 시켜준다.

이러한 코드는 일반적인 반복문보다 더 느리게 동작하며, 특히 try-catch 안의 다른 배열이 존재하고 거기서 예외가 발생하는 경우 
적절한 처리를 하지 못하고 그냥 넘어가버린다.  

<br/>

예외는 진짜 예외 상황이 발생할 경우에만 사용해야 한다. 일반적인 흐름 제어를 위해서는 사용해서는 안된다. 
그리고 이 원칙은 API를 설계할 때도 중요하다. 클라이언트가 예외를 처리하도록 만들지 말자. 

일반적으로 Iterator를 순회하는데 있어서는 ```hasNext()```를 사용한다.

``` java
for(Iterator<Foo> i = collection.iterator() ; i.hasNext() ; ){
	Foo foo = i.next();
}
```

``` java
// iterator를 제공하는 API에서 만약 hasNext() 메소드를 제공하지 않는다면?
// 흉물스러운 코드가 만들어진다.
try{
	Iterator<Foo> i = collection.itrator();
	while(true){
		Foo foo = i.next();
	}
}
catch(NoSuchElementException e){
	// ...
}
```

```hasNext()``` 와 같은 상태 검사 메소드를 제공할 수도 있고 다른 선택지도 존재한다. 
Optional이나 특정 값을 리턴하는 방식이 될 수 있다. 

1. 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 Optional이나 null 같은 특수 값을 사용한다. 상태 검사 메소드와 상태 의존적 메소드 호출 사이에 객체의 상태가 변할 수 있기 때문이다.
2. 성능이 중요한 상황이고, 상태 검사 메소드가 빈번하게 호출되어 중복 수행된다면 Optional이나 null 같은 특수 값을 사용한다.
3. 그 외의 경우라면 가독성 측면을 비롯해 상태 검사 메소드를 작성하는 것이 좋은 방법이다. 