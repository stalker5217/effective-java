## 스트림 병렬화는 주의해서 적용하라  

자바는 전통적으로 병렬 프로그래밍을 지원해왔고, 이는 스트림도 마찬가지다. 
스트림에서는 ```parallel``` 메서드로 파이프 라인을 병렬 실행할 수 있도록 지원한다. 

하지만 이를 올바르게 작성하는 일이란 간단한 것이 아니며, 병렬화를 할 때는 주의해서 진행해야 된다. 

``` java
Stream
		.iterate(BigInteger.TWO, BigInteger::nextProbablePrime)
		.map(p -> BigInteger.TWO.pow(p.intValueExact()).subtract(BigInteger.ONE))
		.filter(mersenne -> mersenne.isProbablePrime(50))
		.limit(20)
		.forEach(mp -> System.out.println(mp.bitLength() + ": " + mp));
```

아이템45에서 작성한 메르센 소수를 구하는 소스에서 20개를 연산하는 것은 몇 초의 시간이 걸린다.
이를 빠르게 처리하기 위해 ```parallel```을 호출했다고 해보자. 

``` java
Stream
		.iterate(BigInteger.TWO, BigInteger::nextProbablePrime)
		.parallel()
		.map(p -> BigInteger.TWO.pow(p.intValueExact()).subtract(BigInteger.ONE))
		.filter(mersenne -> mersenne.isProbablePrime(50))
		.limit(20)
		.forEach(mp -> System.out.println(mp.bitLength() + ": " + mp));
```

안타깝지만 이 소스는 끝날 생각을 하지 않는다. 
스트림 라이브러리가 이 파이프라인을 병렬화하는 방법을 찾지 못했기 때문이다. 

소스가 ```Stream.iterate```인 것과 그리고 ```limit(20)``` 모두 병렬화로 개선할 수 없는 부분이기 때문이다. 
```limit``` 같은 경우 병렬 처리를 할 때 주어진 파라미터 개수보다 좀 더 넉넉히 구해놓고 몇 가지를 버리는 형태로 동작하는데 
오름차순으로 20번 이상의 수를 구하기에는 연산의 오버헤드가 참 크다.

실제로 20번 째 메르센 소수는 비트로 표현했을 때 그 길이만 43이며 10진수로 표현한 결과는 아래와 같다.  

285542542228279613901563566102164008326164238644702889199247456602284400390600653875954571505539843239754513915896150297878399377056071435169747221107988791198200988477531339214282772016059009904586686254989084815735422480409022344297588352526004383890632616124076317387416881148592486188361873904175783145696016919574390765598280188599035578448591077683677175520434074287726578006266759615970759521327828555662781678385691581844436444812511562428136742490459363212810180276096088111401003377570363545725120924073646921576797146199387619296560302680261790118132925012323046444438622308877924609373773012481681672424493674474488537770155783006880852648161513067144814790288366664062257274665275787127374649231096375001170901890786263324619578795731425693805073056119677580338084333381987500902968831935913095269821311141322393356490178488728982288156282600813831296143663845945431144043753821542871277745606447858564159213328443580206422714694913091762716447041689678070096773590429808909616750452927258000843500344831628297089902728649981994387647234574276263729694848304750917174186181130688518792748622612293341368928056634384466646326572476167275660839105650528975713899320211121495795311427946254553305387067821067601768750977866100460014602138408448021225053689054793742003095722096732954750721718115531871310231057902608580607

20번째 수가 이 모양인데 더 넘어서 수를 더 구한다? CPU가 아파할 것이다. 

<br/>

이처럼 병렬화를 잘못하면 끝자니 않는 **응답 불가(liveness failure)** 상태에 빠지게 된다.

이를 방지하기 위해 고려하기 위한 첫 번째는 데이터 소스이다.
병렬화에 좋은 소스들은 ```ArrayList```, ```HashMap```, ```HashSet```, ```ConcurrentHashMap``` 인스턴스거나 
배열, ```int```, ```long``` 범위일 때 효과가 가장 좋다. 

이들은 데이터를 원하는 크기로 쉽게 나눌 수 있어 각각의 스레드에 분배할 수 있다. 
이는 ```Spliterator```가 담당하며 직접 구현한 자료 구조를 잘 병렬화하기 위해서는 이를 재정의하자. 
또한, 참조 지역성(Locality of reference)이 뛰어나다. 
이는 이웃한 원소의 참조들이 메모리에 연속되어 저장되어 있다는 뜻이다. 이게 안 좋으면 병목이 발생할 수 밖에 없다.

두 번째 고려할 점은 종단 연산이다. 
종단 연산의 종류가 병렬 수행에 있어 높은 영향을 포함한다. 
```collect```와 같은 메서드는 컬렉션을 조합하는데 비용이 너무 발생하기에 적합하지 않다. 
가장 적합한 연산은 축소 연산(reduction)이다. 
```min```, ```max```, ```count```, ```sum```과 같은 연산이나, 
```anyMatch```, ```allMatch```, ```noneMatch``` 등의 연산도 병렬화에 적합하다. 

<br/>

병렬화를 잘못했을 때 발생하는 것은 응답이 느려지는 것 외에 아예 결과가 잘못되는 **안전 실패(safety failure)** 가 발생할 수 있다. 

스트림에서 정해놓은 규약이 있다. 
예를 들어 reduce 연산에 건네지는 ```누산기(accumulator)```와 ```결합기(combiner)```는 반드시 아래를 만족해야 한다. 
- associative (연산이 결합 법칙을 만족)
- non-interfering (파이프 라인 실행 중 데이터 소스가 변경되지 않음)
- stateless (무상태)

또 고려해야할 점이 있다. 
위의 메르센 소수를 구하는 것도 오름차순으로 출력되는 것이 아니라 뒤죽박죽으로 출력이 된다. 
이 때는 ```forEach``` 연산 대신 ```forEachOrdered```를 사용하면 된다. 

<br/>

병렬화는 고려해야 할 것이 많다. 
위의 모든 조건을 만족해도 병렬화에 발생되는 비용으로 인해 성능 향상이 없을 수도 있다. 
스트림의 원소들의 연산이 합쳤을 때 최소 수십만 라인은 나와줘야 그래도 성능 향상을 느낄 수 있다. 
분명 스트림 병렬화를 할 일은 그렇게 많지 않으나, 분명히 필요할 때가 있을 수 있다. 
이 때 병렬화를 시도할 때는 면밀히 검토해야하며 진행 한후에도 지속적으로 모니터링이 필요하다.